# 练习 1.10

# 因为 Ruby 中大写字母是用来表示类或常量的，所以方法名换成了小写字母
def a x, y
  case
  when y == 0 then 0
  when x == 0 then 2 * y
  when y == 1 then 2
  else 
    a (x-1), a(x, y-1)
  end
end

puts a 1,10 # => 1024
puts a 2,4 # => 65536
puts a 3,3 # => 65536
puts a 1,5

# a 2,4
# a(1,a(2,3))
# a(1,a(1,a(2,2)))
# a(1,a(1,a(1,a(2,1))))
# a(1,a(1,a(1,2)))
# a(1,a(1,a(0,a(1,1))))
# a(1,a(1,a(0,2)))
# a(1,a(1,4))
# a(1,a(0,a(1,3)))
# a(1,a(0,a(0,a(1,2))))
# a(1,a(0,a(0,a(0,a(1,1)))))
# a(1,a(0,a(0,a(0,2))))
# a(1,a(0,a(0,4)))
# a(1,a(0,8))
# a(1,16)

# a 3,4
# a(2,a(3,3))
# a(2,a(2,a(3,2)))
# a(2,a(2,a(2,a(3,1))))
# a(2,a(2,a(2,2)))
# a(2,a(2,a(1,a(2,1))))
# a(2,a(2,a(1,2)))
# a(2,a(2,a(0,a(1,1))))
# a(2,a(2,a(0,2)))
# a(2,a(2,4))
# a(2,a(1,a(1,4)))
# a(2,a(1,16))
# a(2,2**16)
# a(1,a(1,2**16))
# a(1,2**(2**16))
# 2**(2**(2**16))

def f n
  a 0,n
end
# 因为 调用的 a 参数 x 一直为 0，所以返回值永远是 y * 2 即 n * 2

def g n
  a 1,n
end
# 因为 调用的 a 参数 x 为 1，所以 a 会至少展开一次，而根据 n 的大小，a 还会展开 n - 1 次，所以一共要展开 1+(n-1) = n 次
# 而外部的展开会保持 x 为 0，内部的最后一次展开时， y 会是 1，也就是说返回 2，所以，最后的结果是 2 ** n

def h n
  a 2,n
end
# a(2,n) 会至少展开两次，第一次展开后收缩的结果是 a(1,a(1,n))
# 根据 a(1,n) = 2 ** n 的结果，得出 a(1, 2**n)，继续推导得出 2**(2**n)

def k n
  5 * n * n
end
# 这个就直接是小学数学了。5 * (n**2)

# 虽然没有要求，不过我还是想要推导一下。
def i n
  a 3,n
end
# a(3,n)，第一次展开后，会得出 a(2,a(2,n)), 根据之前的结果，换算为 a(2, 2**(2**n))，继续推导得出 2**(2**(2**n))
# 这么变态的东西来了。

def j n
  a 4,n
end
# 同理，推出 a(4,n) 为 2**(2**(2**(2**(2**(2**n)))))

# 再推下去就没边了。 
